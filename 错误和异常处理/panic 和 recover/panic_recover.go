/*
   引入问题???
		Go 语言通过 error 接口统一进行错误处理，但这些错误都是我们在编写代码时就已经预见并返回的，对于某些运行时错误，比如数组越界、除数为0、空指针引用，
		这些 Go 语言是怎么处理的呢？

   # panic #
		Go 语言没有像 PHP 那样引入异常的概念，也没有提供 try...catch 这样的语法对运行时异常进行捕获和处理，当代码运行时出错，而又没有在编码时显式返回错误时，
		Go 语言会抛出 panic，中文译作「运行时恐慌」，我们也可以将其看作 Go 语言版的异常。

		除了像上篇教程演示的那样由 Go 语言底层抛出 panic，我们还可以在代码中显式抛出 panic，以便对错误和异常信息进行自定义，
		仍然以上篇教程除数为0的示例代码为例，我们可以这样显式返回 panic 中断代码执行：

*/

package main

import "fmt"

func main() {
    defer func() {
        fmt.Println("代码清理逻辑")
    }()

    var i = 1
    var j = 0
    if j == 0 {
        panic("除数不能为0！")
    }
    k := i / j
    fmt.Printf("%d / %d = %d\n", i, j, k)
}

/*
	执行结果：
	
	=====================================================================
			代码清理逻辑
			panic: 除数不能为0！

			goroutine 1 [running]:
			main.main()
					D:/goLang/github/golang_project/错误和异常处理/panic 和 recover/panic_recover.go:27 +0x62
			exit status 2

			第一行表示出问题的协程，
			第二行是问题代码所在的包和函数，
			第三行时问题代码的具体位置，最后一行则是程序的退出状态。
	=====================================================================


	panic 函数支持的参数类型是 interface{}：

	func panic(v interface{})

	所以可以传入任意类型的参数：

	panic(500)   // 传入数字
	panic(errors.New("除数不能为0"))  // 传入 error 类型

	无论是 Go 语言底层抛出 panic，还是我们在代码中显式抛出 panic，处理机制都是一样的：当遇到 panic 时，
	Go 语言会中断当前协程中（main 函数）后续代码的执行，然后执行在中断代码之前定义的 defer 语句（按照先入后出的顺序），
	最后程序退出并输出 panic 错误信息，以及出现错误的堆栈跟踪信息，在这里就是：
*/